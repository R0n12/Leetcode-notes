# #15 3Sum

## Please check the problem description [here](https://leetcode.com/problems/3sum/).

## Two Pointers

```Java
    class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums); // use Arrays.sort to sort int[], not Collections.sort
        List<List<Integer>> result = new ArrayList<>(); //List initialization

        // check if the elt is bigger than 0
        for(int i = 0; i < nums.length && nums[i] <= 0;i++){
            // check if the first elt appeared before
            if( i == 0 || nums[i] != nums[i-1]){
                twoSumII(nums, i, result);
            }
        }
        return result;
    }
    
    void twoSumII(int[] nums, int i, List<List<Integer>> result){
        int lo = i+1,hi = nums.length-1;
        while(lo<hi){
            int sum = nums[i] + nums[lo]+nums[hi];
            // check if lowest elt appeared before
            if(sum < 0 || (lo > i +1 && nums[lo] == nums[lo-1])){
                ++ lo;
            // check if highest elt appeared before
            }else if(sum > 0 || (hi < nums.length-1 && nums[hi] == nums[hi+1])){
                -- hi;
            }else{
                result.add(Arrays.asList(nums[i], nums[lo++], nums[hi--]);
            }
        }
    }
}
```

* `Arrays.sort()`
* `new ArrayList<>();`
* `Arrays.asList()`
* Difference between `++i`, `i++`
* **Logic**: no need to check for elements already `>0`, the sorted array is in ascending order.
* **Logic**: for each element, check if the element appeared before.
* **Logic**: for each lowest and highest elt, check if it appeared before.


>1. Convert the problem to a modified `twoSum` Problem.
>2. sort the array first for quicker and easier logic
>3. set a first pivot element and perform `twoSum` on the remaining array
>4. make sure to check if the pivot is visited & if the high index or low index are visited.
>5. make sure to traverse all the subarray given a pivot point, to collect all possible result, that is keep incrementing low point or decreasing high point.

## Analysis

Runtime: $\mathcal{O}(n^2)$

Space: $\mathcal{O}(log(n))$ to $\mathcal{O}(n)$, depending on `Arrays.sort`









